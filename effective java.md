#卓有成效的Java
- 对象创建和销毁
    - 用静态工厂方法代替构造函数
    - 初始化参数较多时推荐使用构建器
    - 对外隐藏构造函数或者使用枚举实现单例
    - 限定构造函数为private强制保证对外不可实例化
    - 避免创建无用对象
    - 及时释放无效对象引用
    - 禁止调用finalizer方法
- 对象通用方法
    - 同时重写equals方法和hashCode方法
    - 避免使用finalizer方法
    - 非final类尽量不要实现equals方法
    - 遵循equals方法的通用约定（传递性，交换性，非空性）
    - 总是实现toString方法
    - 谨慎地实现clone方法
    - 考虑实现Comparable接口
- 类和接口
    - 精简类和成员的对外接口
    - 避免对外暴露数据属性，使用访问接口代替
    - 精简可修改内容
    - 组合优于继承
    - 为基类提供详细的说明，否则就不要设计该基类
    - 接口优于抽象类
    - 使用接口来定义类型
    - 继承体系优于属性标记
    - 使用函数对象表示策略
    - 优先考虑使用静态方法
- 通用编程规范
    - 缩小变量作用域
    - 遍历优先选用for each
    - 了解并使用现成类库
    - 避免float和double类型数据的严格相等比较
    - 不要随意使用String类型，而要根据实际情况选取更合适的类型或者结构
    - 注意字符拼接的低效问题
    - 通过接口引用对象
    - 接口优于反射
    - 慎重地使用native方法
    - 慎重地优化
    - 遵循约定俗成的命名规则
- 方法约定
    - 检查参数有效性
    - 需要时返回对象拷贝
    - 认真设计方法签名
    - 谨慎使用重载
    - 谨慎使用varargs
    - 返回空的集合对象，而不是Null
    - 为所有对外接口提供详尽的文档说明
- 范型
    - 不要使用不加限定的集合类型
    - 消除编译警告
    - 列表优于数组（列表的非继承特性）
    - 尽量设计范型成员
    - 尽量设计范型方法
    - 使用范型通配符提高API可用性，如集合类对各种类型的支持
    - 考虑类型安全的异构容器（？）
- 枚举和注解
    - 使用枚举代替整型常量
    - 使用属性代替枚举序数
    - 使用EnumSet代替bit字段
    - 使用EnumMap代替序数索引
    - 给枚举建立抽象接口
    - 使用Override注解
    - 使用标记（空）接口定义类型
- 异常
    - 仅对意外情况抛出异常
    - 对可修复错误使用检查型异常，对于程序错误则使用运行时异常
    - 避免不必要的检查型异常
    - 最好使用标准异常
    - 根据异常的抽象定义抛出对应异常
    - 注释说明方法抛出的所有（检查型）异常
    - 抛出异常时，包含详细的异常信息
    - 同失败原子性做抗争
    - 不要忽视异常
- 并发
    - 同步可修改的属性的访问接口
    - 避免过度使用同步
    - 用executor和task代替Thread
    - 使用并发工具包代替wait和notify接口
    - 写文档说明线程安全问题
    - 慎重使用懒加载
    - 不要依赖线程调度器控制
    - 避免使用线程组
- 序列化
    - 慎重地实现Serializable接口
    - 考虑定制序列化格式
    - 认真考虑实现readObject方法
    - 推荐使用枚举实现单例控制
    - 考虑使用序列化代理来实现示例的序列化